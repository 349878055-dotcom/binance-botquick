# 流动性真空狙击系统 - 策略架构设计图 (V1.0)

## 1. 核心设计思想

*   **信号源**：放弃滞后的价格指标，盯住订单簿深度消失速率（Depth Decay）和扫单速度（Sweep Velocity）。
*   **博弈逻辑**：当做市商（Market Maker）因为感知到“有毒流量”而瞬间撤单时，市场会出现流动性真空（Gap）。此时，价格的波动不再是连续的，而是跳跃的。
*   **执行逻辑**：Python 识别出真空瞬间，下达“狙击指令”，C++ 利用预设连接进行不计代价的扫单。

## 2. 物理通信底座 (Shared Memory Topology)

系统采用 `GenericShmStruct` 作为核心总线。为了实现你的诉求，我们将内存区域划分为三个物理功能区：

A. 市场情报传送带 (MarketRingBuffer)

*   **物理位置**：`market_ring`
*   **功能**：由 C++ 实时压入每一帧行情。
*   **Python 用法**：Python 通过 `read_idx` 追赶 `write_idx`。如果发现 `read_idx` 落后 `write_idx` 太多，说明发生剧烈行情，直接跳到最新帧处理“断裂”。

B. 信号雷达区 (AlphaSignals - 待新增)

*   **设计意图**：在 C++ 侧预处理“脏活”，直接给 Python 传递结果。
*   **核心字段设计**：
    *   `bid/ask_decay_rate` (10ms): 挂单撤单率。
    *   `sweep_intensity`: 扫单强度。单笔成交穿透的 Tick 数量。
    *   `liquidity_gap_size`: 当前买一卖一之间的空洞（Spread 扩张度）。
    *   `aggressor_imbalance`: 瞬时主动买卖量的物理失衡比。

C. 指令发射台 (CommandRingBuffer)

*   **物理位置**：`command_ring`
*   **功能**：Python 将 `target_price` 和 `target_amount` 写入 `CommandFrame`。
*   **核心逻辑**：C++ 端的 `Executor` 会死循环轮询这个环形缓冲区，一旦发现新指令，立即击发。

## 3. 核心博弈逻辑：捕获“有毒流量”带来的机会

**第一步：做市商逃离判定 (The Detection)**

*   **现象**：C++ 监测到 `bid_p` (买一价) 没动，但 `bid_q` (买一量) 在 5 毫秒内由于非成交原因萎缩了 90%。
*   **信号**：`AlphaSignals.bid_decay_rate` 飙升。
*   **结论**：做市商感知到了有毒流量，正在撤单。价格即将向下断裂。

**第二步：真空期锁定 (The Gap)**

*   **现象**：买卖价差（Spread）从 0.1 瞬间跳到 5.0。
*   **信号**：`AlphaSignals.liquidity_gap_size` 触发阈值。
*   **结论**：断裂已发生，流动性真空出现。

**第三步：Python 狙击下达 (The Snipe)**

*   **Python 动作**：
    *   读取 `market_ring` 确认最新成交价。
    *   计算狙击区间：`price = market_price - slippage_allowance`。
    *   向 `command_ring` 写入一条 `CommandFrame`。
    *   设置 `strategy_status = 2` (开火)。

## 4. 物理执行约束 (Architectural Constraints)

*   **Cache 对齐**：所有新增字段必须严格遵守 `alignas(64)`，确保数据读取不跨越 CPU 缓存行，保证 Python 读取延迟在微秒级。
*   **原子性保证**：C++ 写入信号时使用 `std::memory_order_release`，Python 读取指令时使用 `std::memory_order_acquire`，确保“看到即真实”。
*   **无锁环形缓冲区**：Python 作为生产者写入 `command_ring`，C++ 作为消费者读取。不需要互斥锁（Mutex），最大限度降低指令下发延迟。

## 5. 待细化细节 (Next Steps)

*   **[物理定义]**：如何区分“正常撤单”与“做市商恐慌性逃跑”？（是否需要加入成交量权重的衰减系数？）
*   **[时间戳审计]**：Python 读到数据到 C++ 发出指令，中间的微秒级延迟是否会导致我们“错位”？（是否需要在 C++ 侧加入价格保护锁？）
*   **[反馈机制]**：当 C++ 发现盘口已经在断裂后重新挂满（做市商回来了），是否应该自动作废 Python 之前的狙击指令？

## 6. 后续细化重点 (Refinement Roadmap)

*   **信号阈值标定**：我们需要确定撤单率达到多少（例如 0.85）才算做市商“溃逃”。
*   **断裂宽度定义**：价格跳空多少个 Tick 算有效断裂。
*   **C++ 预处理器修改**：修改 `Network.cpp`，增加对 `AlphaSignals` 区域的实时填充逻辑。